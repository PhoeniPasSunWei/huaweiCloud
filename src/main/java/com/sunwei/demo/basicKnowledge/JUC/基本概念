1、基本概念
    1.1同步代码块
    使用synchronized关键字加上一个锁对象来定义一段代码，这就叫同步代码块。
    多个同步代码块如果使用相同的锁对象，那么他们就是同步的。
    1.2 进程与线程的区别：
        进程 : 一个运行中的程序的集合; 一个进程往往可以包含多个线程,至少包含一个线程
            java默认有几个线程? 两个 main线程 gc线程
        线程 : 线程（thread）是操作系统能够进行运算调度的最小单位。
    1.3 并发与并行的区别：
        并发(多线程操作同一个资源,交替执行)
            CPU一核, 模拟出来多条线程,天下武功,唯快不破,快速交替
        并行(多个人一起行走, 同时进行)
            CPU多核,多个线程同时进行 ; 使用线程池操作
    1.5 wait/sleep的区别：
        1来自不同的类
            wait来自object类, sleep来自线程类
        2、关于锁的释放
            wait会释放锁, sleep不会释放锁
        3、使用的范围不同
            wait必须在同步代码块中
            sleep可以在任何地方睡
        4、是否需要捕获异常
            wait不需要捕获异常
            sleep需要捕获异常
2、JUC的结构
    1，tools（工具类）：又叫信号量三组工具类，包含有
        1）CountDownLatch（闭锁） 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待
        2）CyclicBarrier（栅栏） 之所以叫barrier，是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。
        3）Semaphore（信号量） 是一个计数信号量，它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。=
    2，executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：
        1）ScheduledExecutorService 解决那些需要任务重复执行的问题
        2）ScheduledThreadPoolExecutor 周期性任务调度的类实现
        3，atomic(原子性包)：是JDK提供的一组原子操作类，
        包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，他们的实现原理大多是持有它们各自的对应的类型变量value，而且被volatile关键字修饰了。这样来保证每次一个线程要使用它都会拿到最新的值。
    4，locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：
        1）ReentrantLock 它是独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。
        2）ReentrantReadWriteLock 它包括子类ReadLock和WriteLock。ReadLock是共享锁，而WriteLock是独占锁。
        3）LockSupport 它具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。
    5，collections(集合类)：主要是提供线程安全的集合， 比如：
        1）ArrayList对应的高并发类是CopyOnWriteArrayList，
        2）HashSet对应的高并发类是 CopyOnWriteArraySet，
        3）HashMap对应的高并发类是ConcurrentHashMap等等

广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁

公平锁: 十分公平: 可以先来后到,一定要排队
非公平锁: 十分不公平,可以插队(默认)

